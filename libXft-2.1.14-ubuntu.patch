diff -Naur libXft-2.1.14.orig/src/xftdpy.c libXft-2.1.14/src/xftdpy.c
--- libXft-2.1.14.orig/src/xftdpy.c	2009-01-30 00:19:09.000000000 +0100
+++ libXft-2.1.14/src/xftdpy.c	2009-10-17 14:27:29.000000000 +0200
@@ -369,6 +369,10 @@
 	goto bail1;
     if (!_XftDefaultInitInteger (dpy, pat, FC_RGBA))
 	goto bail1;
+#ifdef FC_LCD_FILTER
+    if (!_XftDefaultInitInteger (dpy, pat, FC_LCD_FILTER))
+	goto bail1;
+#endif
     if (!_XftDefaultInitBool (dpy, pat, FC_ANTIALIAS))
 	goto bail1;
 #ifdef FC_EMBOLDEN
@@ -521,6 +525,14 @@
 			      XftDefaultGetInteger (dpy, FC_RGBA, screen, 
 						    subpixel));
     }
+#ifdef FC_LCD_FILTER
+    if (FcPatternGet (pattern, FC_LCD_FILTER, 0, &v) == FcResultNoMatch)
+    {
+	FcPatternAddInteger (pattern, FC_LCD_FILTER,
+			     XftDefaultGetInteger (dpy, FC_LCD_FILTER, screen,
+						   FC_LCD_DEFAULT));
+    }
+#endif
     if (FcPatternGet (pattern, FC_MINSPACE, 0, &v) == FcResultNoMatch)
     {
 	FcPatternAddBool (pattern, FC_MINSPACE,
diff -Naur libXft-2.1.14.orig/src/xftfreetype.c libXft-2.1.14/src/xftfreetype.c
--- libXft-2.1.14.orig/src/xftfreetype.c	2009-01-30 00:19:09.000000000 +0100
+++ libXft-2.1.14/src/xftfreetype.c	2009-10-17 14:27:29.000000000 +0200
@@ -469,6 +469,21 @@
 	goto bail1;
     }
     
+#ifdef FC_LCD_FILTER 
+    /*
+     * Get lcd_filter value
+     */
+    switch (FcPatternGetInteger (pattern, FC_LCD_FILTER, 0, &fi->lcd_filter)) {
+    case FcResultNoMatch:
+	fi->lcd_filter = FC_LCD_DEFAULT;
+	break;
+    case FcResultMatch:
+	break;
+    default:
+	goto bail1;
+    }
+#endif
+    
     /*
      * Get matrix and transform values
      */
diff -Naur libXft-2.1.14.orig/src/xftfreetype.c.orig libXft-2.1.14/src/xftfreetype.c.orig
--- libXft-2.1.14.orig/src/xftfreetype.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ libXft-2.1.14/src/xftfreetype.c.orig	2009-01-30 00:19:09.000000000 +0100
@@ -0,0 +1,1174 @@
+/*
+ * Copyright Â© 2000 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "xftint.h"
+
+_X_HIDDEN FT_Library  _XftFTlibrary;
+
+#define FT_Matrix_Equal(a,b)	((a)->xx == (b)->xx && \
+				 (a)->yy == (b)->yy && \
+				 (a)->xy == (b)->xy && \
+				 (a)->yx == (b)->yx)
+/*
+ * List of all open files (each face in a file is managed separately)
+ */
+
+static XftFtFile *_XftFtFiles;
+static int XftMaxFreeTypeFiles = 5;
+
+static XftFtFile *
+_XftGetFile (const FcChar8 *file, int id)
+{
+    XftFtFile	*f;
+
+    if (!XftInitFtLibrary ())
+	return NULL;
+
+    for (f = _XftFtFiles; f; f = f->next)
+    {
+	if (!strcmp (f->file, (char *) file) && f->id == id)
+	{
+	    ++f->ref;
+	    if (XftDebug () & XFT_DBG_REF)
+		printf ("FontFile %s/%d matches existing (%d)\n",
+			file, id, f->ref);
+	    return f;
+	}
+    }
+    f = malloc (sizeof (XftFtFile) + strlen ((char *) file) + 1);
+    if (!f)
+	return NULL;
+    
+    XftMemAlloc (XFT_MEM_FILE, sizeof (XftFtFile) + strlen ((char *) file) + 1);
+    if (XftDebug () & XFT_DBG_REF)
+    	printf ("FontFile %s/%d matches new\n",
+		file, id);
+    f->next = _XftFtFiles;
+    _XftFtFiles = f;
+    
+    f->ref = 1;
+    
+    f->file = (char *) (f+1);
+    strcpy (f->file, (char *) file);
+    f->id = id;
+    
+    f->lock = 0;
+    f->face = NULL;
+    f->xsize = 0;
+    f->ysize = 0;
+    f->matrix.xx = f->matrix.xy = f->matrix.yx = f->matrix.yy = 0;
+    return f;
+}
+
+static XftFtFile *
+_XftGetFaceFile (FT_Face face)
+{
+    XftFtFile	*f;
+
+    f = malloc (sizeof (XftFtFile));
+    if (!f)
+	return NULL;
+    XftMemAlloc (XFT_MEM_FILE, sizeof(XftFtFile));
+    f->next = NULL;
+    
+    f->ref = 1;
+
+    f->file = NULL;
+    f->id = 0;
+    f->lock = 0;
+    f->face = face;
+    f->xsize = 0;
+    f->ysize = 0;
+    f->matrix.xx = f->matrix.xy = f->matrix.yx = f->matrix.yy = 0;
+    return f;
+}
+
+static int
+_XftNumFiles (void)
+{
+    XftFtFile	*f;
+    int		count = 0;
+    for (f = _XftFtFiles; f; f = f->next)
+	if (f->face && !f->lock)
+	    ++count;
+    return count;
+}
+
+static XftFtFile *
+_XftNthFile (int n)
+{
+    XftFtFile	*f;
+    int		count = 0;
+    for (f = _XftFtFiles; f; f = f->next)
+	if (f->face && !f->lock)
+	    if (count++ == n)
+		break;
+    return f;
+}
+
+static void
+_XftUncacheFiles (void)
+{
+    int		n;
+    XftFtFile	*f;
+    while ((n = _XftNumFiles ()) > XftMaxFreeTypeFiles)
+    {
+	f = _XftNthFile (rand () % n);
+	if (f)
+	{
+	    if (XftDebug() & XFT_DBG_REF)
+		printf ("Discard file %s/%d from cache\n",
+			f->file, f->id);
+	    FT_Done_Face (f->face);
+	    f->face = NULL;
+	}
+    }
+}
+
+static FT_Face
+_XftLockFile (XftFtFile *f)
+{
+    ++f->lock;
+    if (!f->face)
+    {
+	if (XftDebug() & XFT_DBG_REF)
+	    printf ("Loading file %s/%d\n", f->file, f->id);
+	if (FT_New_Face (_XftFTlibrary, f->file, f->id, &f->face))
+	    --f->lock;
+	    
+	f->xsize = 0;
+	f->ysize = 0;
+	f->matrix.xx = f->matrix.xy = f->matrix.yx = f->matrix.yy = 0;
+	_XftUncacheFiles ();
+    }
+    return f->face;
+}
+
+static void
+_XftLockError (char *reason)
+{
+    fprintf (stderr, "Xft: locking error %s\n", reason);
+}
+
+static void
+_XftUnlockFile (XftFtFile *f)
+{
+    if (--f->lock < 0)
+	_XftLockError ("too many file unlocks");
+}
+
+#if HAVE_FT_BITMAP_SIZE_Y_PPEM
+#define X_SIZE(face,i) ((face)->available_sizes[i].x_ppem)
+#define Y_SIZE(face,i) ((face)->available_sizes[i].y_ppem)
+#else
+#define X_SIZE(face,i) ((face)->available_sizes[i].width << 6)
+#define Y_SIZE(face,i) ((face)->available_sizes[i].height << 6)
+#endif
+
+_X_HIDDEN FcBool
+_XftSetFace (XftFtFile *f, FT_F26Dot6 xsize, FT_F26Dot6 ysize, FT_Matrix *matrix)
+{
+    FT_Face face = f->face;
+    
+    if (f->xsize != xsize || f->ysize != ysize)
+    {
+	if (XftDebug() & XFT_DBG_GLYPH)
+	    printf ("Set face size to %dx%d (%dx%d)\n", 
+		    (int) (xsize >> 6), (int) (ysize >> 6), (int) xsize, (int) ysize);
+	/*
+	 * Bitmap only faces must match exactly, so find the closest
+	 * one (height dominant search)
+	 */
+	if (!(face->face_flags & FT_FACE_FLAG_SCALABLE))
+	{
+	    int		i, best = 0;
+
+#define xft_abs(a)	((a) < 0 ? -(a) : (a))
+#define dist(a,b)	(xft_abs((a)-(b)))
+
+	    for (i = 1; i < face->num_fixed_sizes; i++)
+	    {
+		if (dist (ysize, Y_SIZE(face,i)) <
+		    dist (ysize, Y_SIZE(face, best)) ||
+		    (dist (ysize, Y_SIZE(face, i)) ==
+		     dist (ysize, Y_SIZE(face, best)) &&
+		     dist (xsize, X_SIZE(face, i)) <
+		     dist (xsize, X_SIZE(face, best))))
+		{
+		    best = i;
+		}
+	    }
+	    /* 
+	     * Freetype 2.1.7 and earlier used width/height
+	     * for matching sizes in the BDF and PCF loaders.
+	     * This has been fixed for 2.1.8.  Because BDF and PCF
+	     * files have but a single strike per file, we can
+	     * simply try both sizes.
+	     */
+	    if (
+#if HAVE_FT_BITMAP_SIZE_Y_PPEM
+		FT_Set_Char_Size (face, face->available_sizes[best].x_ppem,
+				  face->available_sizes[best].y_ppem, 0, 0) != 0
+		&&
+#endif
+		FT_Set_Char_Size (face, face->available_sizes[best].width << 6,
+				  face->available_sizes[best].height << 6,
+				  0, 0) != 0)
+	    {
+		return False;
+	    }
+	}
+	else
+    	{
+	    if (FT_Set_Char_Size (face, xsize, ysize, 0, 0))
+	    {
+		return False;
+	    }
+	}
+	f->xsize = xsize;
+	f->ysize = ysize;
+    }
+    if (!FT_Matrix_Equal (&f->matrix, matrix))
+    {
+	if (XftDebug() & XFT_DBG_GLYPH)
+	    printf ("Set face matrix to (%g,%g,%g,%g)\n",
+		    (double) matrix->xx / 0x10000,
+		    (double) matrix->xy / 0x10000,
+		    (double) matrix->yx / 0x10000,
+		    (double) matrix->yy / 0x10000);
+	FT_Set_Transform (face, matrix, NULL);
+	f->matrix = *matrix;
+    }
+    return True;
+}
+
+static void
+_XftReleaseFile (XftFtFile *f)
+{
+    XftFtFile	**prev;
+    
+    if (--f->ref != 0)
+        return;
+    if (f->lock)
+	_XftLockError ("Attempt to close locked file");
+    if (f->file)
+    {
+	for (prev = &_XftFtFiles; *prev; prev = &(*prev)->next)
+	{
+	    if (*prev == f)
+	    {
+		*prev = f->next;
+		break;
+	    }
+	}
+	if (f->face)
+	    FT_Done_Face (f->face);
+    }
+    XftMemFree (XFT_MEM_FILE, 
+		sizeof (XftFtFile) + (f->file ? strlen (f->file) + 1 : 0));
+    free (f);
+}
+
+/*
+ * Find a prime larger than the minimum reasonable hash size
+ */
+
+static FcChar32
+_XftSqrt (FcChar32 a)
+{
+    FcChar32	    l, h, m;
+
+    l = 2;
+    h = a/2;
+    while ((h-l) > 1)
+    {
+	m = (h+l) >> 1;
+	if (m * m < a)
+	    l = m;
+	else
+	    h = m;
+    }
+    return h;
+}
+
+static FcBool
+_XftIsPrime (FcChar32 i)
+{
+    FcChar32	l, t;
+
+    if (i < 2)
+	return FcFalse;
+    if ((i & 1) == 0)
+    {
+	if (i == 2)
+	    return FcTrue;
+	return FcFalse;
+    }
+    l = _XftSqrt (i) + 1;
+    for (t = 3; t <= l; t += 2)
+	if (i % t == 0)
+	    return FcFalse;
+    return FcTrue;
+}
+
+static FcChar32
+_XftHashSize (FcChar32 num_unicode)
+{
+    /* at least 31.25 % extra space */
+    FcChar32	hash = num_unicode + (num_unicode >> 2) + (num_unicode >> 4);
+
+    if ((hash & 1) == 0)
+	hash++;
+    while (!_XftIsPrime (hash))
+	hash += 2;
+    return hash;
+}
+
+_X_EXPORT FT_Face
+XftLockFace (XftFont *public)
+{
+    XftFontInt	*font = (XftFontInt *) public;
+    XftFontInfo	*fi = &font->info;
+    FT_Face	face;
+    
+    face = _XftLockFile (fi->file);
+    /*
+     * Make sure the face is usable at the requested size
+     */
+    if (face && !_XftSetFace (fi->file, fi->xsize, fi->ysize, &fi->matrix))
+    {
+	_XftUnlockFile (fi->file);
+	face = NULL;
+    }
+    return face;
+}
+
+_X_EXPORT void
+XftUnlockFace (XftFont *public)
+{
+    XftFontInt	*font = (XftFontInt *) public;
+    _XftUnlockFile (font->info.file);
+}
+
+static FcBool
+XftFontInfoFill (Display *dpy, _Xconst FcPattern *pattern, XftFontInfo *fi)
+{
+    XftDisplayInfo  *info = _XftDisplayInfoGet (dpy, True);
+    FcChar8	    *filename;
+    int		    id;
+    double	    dsize;
+    double	    aspect;
+    FcMatrix	    *font_matrix;
+    FcBool	    hinting, vertical_layout, autohint, global_advance;
+#ifdef FC_HINT_STYLE
+    int             hint_style;
+#endif
+    FcChar32	    hash, *hashp;
+    FT_Face	    face;
+    int		    nhash;
+    FcBool	    bitmap;
+
+    if (!info)
+	return FcFalse;
+
+    /*
+     * Initialize the whole XftFontInfo so that padding doesn't interfere with
+     * hash or XftFontInfoEqual().
+     */
+ 
+    memset (fi, '\0', sizeof(*fi));
+
+    /*
+     * Find the associated file
+     */
+    switch (FcPatternGetString (pattern, FC_FILE, 0, &filename)) {
+    case FcResultNoMatch:
+	filename = NULL;
+	break;
+    case FcResultMatch:
+	break;
+    default:
+	goto bail0;
+    }
+    
+    switch (FcPatternGetInteger (pattern, FC_INDEX, 0, &id)) {
+    case FcResultNoMatch:
+	id = 0;
+	break;
+    case FcResultMatch:
+	break;
+    default:
+	goto bail0;
+    }
+    
+    if (filename)
+	fi->file = _XftGetFile (filename, id);
+    else if (FcPatternGetFTFace (pattern, FC_FT_FACE, 0, &face) == FcResultMatch
+	     && face)
+	fi->file = _XftGetFaceFile (face);
+    if (!fi->file)
+        goto bail0;
+
+    /*
+     * Compute pixel size
+     */
+    if (FcPatternGetDouble (pattern, FC_PIXEL_SIZE, 0, &dsize) != FcResultMatch)
+	goto bail1;
+
+    if (FcPatternGetDouble (pattern, FC_ASPECT, 0, &aspect) != FcResultMatch)
+	aspect = 1.0;
+    
+    fi->ysize = (FT_F26Dot6) (dsize * 64.0);
+    fi->xsize = (FT_F26Dot6) (dsize * aspect * 64.0);
+
+    if (XftDebug() & XFT_DBG_OPEN)
+	printf ("XftFontInfoFill: %s: %d (%g pixels)\n",
+		(filename ? filename : (FcChar8 *) "<none>"), id, dsize);
+    /*
+     * Get antialias value
+     */
+    switch (FcPatternGetBool (pattern, FC_ANTIALIAS, 0, &fi->antialias)) {
+    case FcResultNoMatch:
+	fi->antialias = True;
+	break;
+    case FcResultMatch:
+	break;
+    default:
+	goto bail1;
+    }
+    
+    /*
+     * Get rgba value
+     */
+    switch (FcPatternGetInteger (pattern, FC_RGBA, 0, &fi->rgba)) {
+    case FcResultNoMatch:
+	fi->rgba = FC_RGBA_UNKNOWN;
+	break;
+    case FcResultMatch:
+	break;
+    default:
+	goto bail1;
+    }
+    
+    /*
+     * Get matrix and transform values
+     */
+    switch (FcPatternGetMatrix (pattern, FC_MATRIX, 0, &font_matrix)) {
+    case FcResultNoMatch:
+	fi->matrix.xx = fi->matrix.yy = 0x10000;
+	fi->matrix.xy = fi->matrix.yx = 0;
+	break;
+    case FcResultMatch:
+	fi->matrix.xx = 0x10000L * font_matrix->xx;
+	fi->matrix.yy = 0x10000L * font_matrix->yy;
+	fi->matrix.xy = 0x10000L * font_matrix->xy;
+	fi->matrix.yx = 0x10000L * font_matrix->yx;
+	break;
+    default:
+	goto bail1;
+    }
+
+    fi->transform = (fi->matrix.xx != 0x10000 || fi->matrix.xy != 0 ||
+		     fi->matrix.yx != 0 || fi->matrix.yy != 0x10000);
+    
+    /* 
+     * Get render value, set to false if no Render extension present
+     */
+    if (info->hasRender)
+    {
+	switch (FcPatternGetBool (pattern, XFT_RENDER, 0, &fi->render)) {
+	case FcResultNoMatch:
+	    fi->render = info->hasRender;
+	    break;
+	case FcResultMatch:
+	    break;
+	default:
+	    goto bail1;
+	}
+    }
+    else
+	fi->render = FcFalse;
+    
+    /*
+     * Compute glyph load flags
+     */
+    fi->load_flags = FT_LOAD_DEFAULT;
+
+#ifndef XFT_EMBEDDED_BITMAP
+#define XFT_EMBEDDED_BITMAP "embeddedbitmap"
+#endif
+
+    switch (FcPatternGetBool (pattern, XFT_EMBEDDED_BITMAP, 0, &bitmap)) {
+    case FcResultNoMatch:
+	bitmap = FcFalse;
+	break;
+    case FcResultMatch:
+	break;
+    default:
+	goto bail1;
+    }
+
+    /* disable bitmaps when anti-aliasing or transforming glyphs */
+    if ((!bitmap && fi->antialias) || fi->transform)
+	fi->load_flags |= FT_LOAD_NO_BITMAP;
+    
+    /* disable hinting if requested */
+    switch (FcPatternGetBool (pattern, FC_HINTING, 0, &hinting)) {
+    case FcResultNoMatch:
+	hinting = FcTrue;
+	break;
+    case FcResultMatch:
+	break;
+    default:
+	goto bail1;
+    }
+
+#ifdef FC_EMBOLDEN
+    switch (FcPatternGetBool (pattern, FC_EMBOLDEN, 0, &fi->embolden)) {
+    case FcResultNoMatch:
+	fi->embolden = FcFalse;
+	break;
+    case FcResultMatch:
+	break;
+    default:
+	goto bail1;
+    }
+#else
+    fi->embolden = FcFalse;
+#endif
+    
+#ifdef FC_HINT_STYLE
+    switch (FcPatternGetInteger (pattern, FC_HINT_STYLE, 0, &hint_style)) {
+    case FcResultNoMatch:
+	hint_style = FC_HINT_FULL;
+	break;
+    case FcResultMatch:
+	break;
+    default:
+	goto bail1;
+    }
+#endif
+
+    if (!hinting
+#ifdef FC_HINT_STYLE
+	|| hint_style == FC_HINT_NONE
+#endif
+	)
+    {
+	fi->load_flags |= FT_LOAD_NO_HINTING;
+    }
+
+    /* Figure out the load target, which modifies the hinting
+     * behavior of FreeType based on the intended use of the glyphs.
+     */
+    if (fi->antialias)
+    {
+#ifdef FC_HINT_STYLE
+#ifdef FT_LOAD_TARGET_LIGHT
+	if (FC_HINT_NONE < hint_style && hint_style < FC_HINT_FULL)
+	{
+	    fi->load_flags |= FT_LOAD_TARGET_LIGHT;
+	}
+	else
+#endif
+#endif
+	{
+	    /* autohinter will snap stems to integer widths, when
+	     * the LCD targets are used.
+	     */
+	    switch (fi->rgba) {
+	    case FC_RGBA_RGB:
+	    case FC_RGBA_BGR:
+#ifdef FT_LOAD_TARGET_LCD
+		fi->load_flags |= FT_LOAD_TARGET_LCD;
+#endif
+		break;
+	    case FC_RGBA_VRGB:
+	    case FC_RGBA_VBGR:
+#ifdef FT_LOAD_TARGET_LCD_V
+		fi->load_flags |= FT_LOAD_TARGET_LCD_V;
+#endif
+		break;
+	    }
+	}
+    }
+#ifdef FT_LOAD_TARGET_MONO
+    else
+	fi->load_flags |= FT_LOAD_TARGET_MONO;
+#endif
+    
+    /* set vertical layout if requested */
+    switch (FcPatternGetBool (pattern, FC_VERTICAL_LAYOUT, 0, &vertical_layout)) {
+    case FcResultNoMatch:
+	vertical_layout = FcFalse;
+	break;
+    case FcResultMatch:
+	break;
+    default:
+	goto bail1;
+    }
+
+    if (vertical_layout)
+	fi->load_flags |= FT_LOAD_VERTICAL_LAYOUT;
+
+    /* force autohinting if requested */
+    switch (FcPatternGetBool (pattern, FC_AUTOHINT, 0, &autohint)) {
+    case FcResultNoMatch:
+	autohint = FcFalse;
+	break;
+    case FcResultMatch:
+	break;
+    default:
+	goto bail1;
+    }
+
+    if (autohint)
+	fi->load_flags |= FT_LOAD_FORCE_AUTOHINT;
+
+    /* disable global advance width (for broken DynaLab TT CJK fonts) */
+    switch (FcPatternGetBool (pattern, FC_GLOBAL_ADVANCE, 0, &global_advance)) {
+    case FcResultNoMatch:
+	global_advance = FcTrue;
+	break;
+    case FcResultMatch:
+	break;
+    default:
+	goto bail1;
+    }
+
+    if (!global_advance)
+	fi->load_flags |= FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH;
+    
+    /*
+     * Get requested spacing value
+     */
+    switch (FcPatternGetInteger (pattern, FC_SPACING, 0, &fi->spacing)) {
+    case FcResultNoMatch:
+	fi->spacing = FC_PROPORTIONAL;
+	break;
+    case FcResultMatch:
+	break;
+    default:
+	goto bail1;
+    }
+    
+    /*
+     * Check for minspace
+     */
+
+    switch (FcPatternGetBool (pattern, FC_MINSPACE, 0, &fi->minspace)) {
+    case FcResultNoMatch:
+	fi->minspace = FcFalse;
+	break;
+    case FcResultMatch:
+	break;
+    default:
+	goto bail1;
+    }
+    /*
+     * Check for fixed pixel spacing 
+     */
+    switch (FcPatternGetInteger (pattern, FC_CHAR_WIDTH, 0, &fi->char_width)) {
+    case FcResultNoMatch:
+	fi->char_width = 0;
+	break;
+    case FcResultMatch:
+	if (fi->char_width)
+	    fi->spacing = FC_MONO;
+	break;
+    default:
+	goto bail1;
+    }
+
+    /*
+     * Step over hash value in the structure
+     */
+    hash = 0;
+    hashp = (FcChar32 *) fi + 1;
+    nhash = (sizeof (XftFontInfo) / sizeof (FcChar32)) - 1;
+
+    while (nhash--)
+	hash += *hashp++;
+    fi->hash = hash;
+    
+    /*
+     * All done
+     */
+    return FcTrue;
+    
+bail1:
+    _XftReleaseFile (fi->file);
+    fi->file = NULL;
+bail0:
+    return FcFalse;
+}
+
+static void
+XftFontInfoEmpty (Display *dpy, XftFontInfo *fi)
+{
+    if (fi->file)
+	_XftReleaseFile (fi->file);
+}
+
+XftFontInfo *
+XftFontInfoCreate (Display *dpy, _Xconst FcPattern *pattern)
+{
+    XftFontInfo	*fi = malloc (sizeof (XftFontInfo));
+
+    if (!fi)
+	return NULL;
+    
+    if (!XftFontInfoFill (dpy, pattern, fi))
+    {
+	free (fi);
+	fi = NULL;
+    }
+    XftMemAlloc (XFT_MEM_FONT, sizeof (XftFontInfo));
+    return fi;
+}
+
+_X_EXPORT void
+XftFontInfoDestroy (Display *dpy, XftFontInfo *fi)
+{
+    XftFontInfoEmpty (dpy, fi);
+    XftMemFree (XFT_MEM_FONT, sizeof (XftFontInfo));
+    free (fi);
+}
+
+_X_EXPORT FcChar32
+XftFontInfoHash (_Xconst XftFontInfo *fi)
+{
+    return fi->hash;
+}
+    
+_X_EXPORT FcBool
+XftFontInfoEqual (_Xconst XftFontInfo *a, _Xconst XftFontInfo *b)
+{
+    return memcmp ((void *) a, (void *) b, sizeof (XftFontInfo)) == 0;
+}
+
+_X_EXPORT XftFont *
+XftFontOpenInfo (Display	*dpy, 
+		 FcPattern	*pattern, 
+		 XftFontInfo	*fi)
+{
+    XftDisplayInfo	*info = _XftDisplayInfoGet (dpy, True);
+    FT_Face		face;
+    XftFont		**bucket;
+    XftFontInt		*font;
+    XRenderPictFormat	*format;
+    FcCharSet		*charset;
+    FcChar32		num_unicode;
+    FcChar32		hash_value;
+    FcChar32		rehash_value;
+    FcBool		antialias;
+    int			max_glyph_memory;
+    int			alloc_size;
+    int			ascent, descent, height;
+    int			i;
+    int			num_glyphs;
+
+    if (!info)
+	return NULL;
+    /*
+     * Find a matching previously opened font
+     */
+    bucket = &info->fontHash[fi->hash % XFT_NUM_FONT_HASH];
+    for (font = (XftFontInt *) *bucket; font; font = (XftFontInt *) font->hash_next)
+	if (XftFontInfoEqual (&font->info, fi))
+	{
+	    if (!font->ref++)
+		--info->num_unref_fonts;
+	    FcPatternDestroy (pattern);
+	    return &font->public;
+	}
+
+    /*
+     * No existing font, create another.  
+     */
+    
+    if (XftDebug () & XFT_DBG_CACHE)
+	printf ("New font %s/%d size %dx%d\n",
+		fi->file->file, fi->file->id,
+		(int) fi->xsize >> 6, (int) fi->ysize >> 6);
+		
+    if (FcPatternGetInteger (pattern, XFT_MAX_GLYPH_MEMORY, 0,
+			     &max_glyph_memory) != FcResultMatch)
+	max_glyph_memory = XFT_FONT_MAX_GLYPH_MEMORY;
+
+    face = _XftLockFile (fi->file);
+    if (!face)
+	goto bail0;
+
+    if (!_XftSetFace (fi->file, fi->xsize, fi->ysize, &fi->matrix))
+	goto bail1;
+
+    /*
+     * Get the set of Unicode codepoints covered by the font.
+     * If the incoming pattern doesn't provide this data, go
+     * off and compute it.  Yes, this is expensive, but it's
+     * required to map Unicode to glyph indices.
+     */
+    if (FcPatternGetCharSet (pattern, FC_CHARSET, 0, &charset) == FcResultMatch)
+	charset = FcCharSetCopy (charset);
+    else
+	charset = FcFreeTypeCharSet (face, FcConfigGetBlanks (NULL));
+    
+    antialias = fi->antialias;
+    if (!(face->face_flags & FT_FACE_FLAG_SCALABLE))
+	antialias = FcFalse;
+
+    /*
+     * Find the appropriate picture format
+     */
+    if (fi->render)
+    {
+	if (antialias)
+	{
+	    switch (fi->rgba) {
+	    case FC_RGBA_RGB:
+	    case FC_RGBA_BGR:
+	    case FC_RGBA_VRGB:
+	    case FC_RGBA_VBGR:
+		format = XRenderFindStandardFormat (dpy, PictStandardARGB32);
+		break;
+	    default:
+		format = XRenderFindStandardFormat (dpy, PictStandardA8);
+		break;
+	    }
+	}
+	else
+	{
+	    format = XRenderFindStandardFormat (dpy, PictStandardA1);
+	}
+	
+	if (!format)
+	    goto bail2;
+    }
+    else
+	format = NULL;
+    
+    if (charset)
+    {
+	num_unicode = FcCharSetCount (charset);
+	hash_value = _XftHashSize (num_unicode);
+	rehash_value = hash_value - 2;
+    }
+    else
+    {
+	num_unicode = 0;
+	hash_value = 0;
+	rehash_value = 0;
+    }
+    
+    /*
+     * Sometimes the glyphs are numbered 1..n, other times 0..n-1,
+     * accept either numbering scheme by making room in the table
+     */
+    num_glyphs = face->num_glyphs + 1;
+    alloc_size = (sizeof (XftFontInt) + 
+		  num_glyphs * sizeof (XftGlyph *) +
+		  hash_value * sizeof (XftUcsHash));
+    font = malloc (alloc_size);
+    
+    if (!font)
+	goto bail2;
+
+    XftMemAlloc (XFT_MEM_FONT, alloc_size);
+
+    /*
+     * Public fields
+     */
+    if (fi->transform)
+    {
+	FT_Vector	vector;
+	
+	vector.x = 0;
+	vector.y = face->size->metrics.descender;
+	FT_Vector_Transform (&vector, &fi->matrix);
+	descent = -(vector.y >> 6);
+	
+	vector.x = 0;
+	vector.y = face->size->metrics.ascender;
+	FT_Vector_Transform (&vector, &fi->matrix);
+	ascent = vector.y >> 6;
+
+	if (fi->minspace)
+	    height = ascent + descent;
+	else
+	{
+	    vector.x = 0;
+	    vector.y = face->size->metrics.height;
+	    FT_Vector_Transform (&vector, &fi->matrix);
+	    height = vector.y >> 6;
+	}
+    }
+    else
+    {
+	descent = -(face->size->metrics.descender >> 6);
+	ascent = face->size->metrics.ascender >> 6;
+	if (fi->minspace)
+	    height = ascent + descent;
+	else
+	    height = face->size->metrics.height >> 6;
+    }
+    font->public.ascent = ascent;
+    font->public.descent = descent;
+    font->public.height = height;
+    
+    if (fi->char_width)
+	font->public.max_advance_width = fi->char_width;
+    else
+    {
+	if (fi->transform)
+	{
+	    FT_Vector	vector;
+	    vector.x = face->size->metrics.max_advance;
+	    vector.y = 0;
+	    FT_Vector_Transform (&vector, &fi->matrix);
+	    font->public.max_advance_width = vector.x >> 6;
+	}
+	else
+	    font->public.max_advance_width = face->size->metrics.max_advance >> 6;
+    }
+    font->public.charset = charset;
+    font->public.pattern = pattern;
+    
+    /*
+     * Management fields
+     */
+    font->ref = 1;
+
+    font->next = info->fonts;
+    info->fonts = &font->public;
+    
+    font->hash_next = *bucket;
+    *bucket = &font->public;
+    
+    /*
+     * Copy the info over
+     */
+    font->info = *fi;
+    /*
+     * reset the antialias field.  It can't
+     * be set correctly until the font is opened,
+     * which doesn't happen in XftFontInfoFill
+     */
+    font->info.antialias = antialias;
+    /*
+     * bump XftFile reference count
+     */
+    font->info.file->ref++;
+    
+    /*
+     * Per glyph information
+     */
+    font->glyphs = (XftGlyph **) (font + 1);
+    memset (font->glyphs, '\0', num_glyphs * sizeof (XftGlyph *));
+    font->num_glyphs = num_glyphs;
+    /*
+     * Unicode hash table information
+     */
+    font->hash_table = (XftUcsHash *) (font->glyphs + font->num_glyphs);
+    for (i = 0; i < hash_value; i++)
+    {
+	font->hash_table[i].ucs4 = ((FcChar32) ~0);
+	font->hash_table[i].glyph = 0;
+    }
+    font->hash_value = hash_value;
+    font->rehash_value = rehash_value;
+    /*
+     * X specific fields
+     */
+    font->glyphset = 0;
+    font->format = format;
+    
+    /*
+     * Glyph memory management fields
+     */
+    font->glyph_memory = 0;
+    font->max_glyph_memory = max_glyph_memory;
+    font->use_free_glyphs = info->use_free_glyphs;
+    
+    _XftUnlockFile (fi->file);
+
+    return &font->public;
+    
+bail2:
+    FcCharSetDestroy (charset);
+bail1:
+    _XftUnlockFile (fi->file);
+bail0:
+    return NULL;
+}
+
+_X_EXPORT XftFont *
+XftFontOpenPattern (Display *dpy, FcPattern *pattern)
+{
+    XftFontInfo	    info;
+    XftFont	    *font;
+
+    if (!XftFontInfoFill (dpy, pattern, &info))
+	return NULL;
+
+    font = XftFontOpenInfo (dpy, pattern, &info);
+    XftFontInfoEmpty (dpy, &info);
+    return font;
+}
+
+_X_EXPORT XftFont *
+XftFontCopy (Display *dpy, XftFont *public)
+{
+    XftFontInt	    *font = (XftFontInt *) public;
+
+    font->ref++;
+    return public;
+}
+
+static void
+XftFontDestroy (Display *dpy, XftFont *public)
+{
+    XftDisplayInfo  *info = _XftDisplayInfoGet (dpy, False);
+    XftFontInt	    *font = (XftFontInt *) public;
+    int		    i;
+    
+    /* note reduction in memory use */
+    if (info)
+	info->glyph_memory -= font->glyph_memory;
+    /* Clean up the info */
+    XftFontInfoEmpty (dpy, &font->info);
+    /* Free the glyphset */
+    if (font->glyphset)
+	XRenderFreeGlyphSet (dpy, font->glyphset);
+    /* Free the glyphs */
+    for (i = 0; i < font->num_glyphs; i++)
+    {
+	XftGlyph	*xftg = font->glyphs[i];
+	if (xftg)
+	{
+	    if (xftg->bitmap)
+		free (xftg->bitmap);
+	    free (xftg);
+	}
+    }
+    
+    /* Free the pattern and the charset */
+    FcPatternDestroy (font->public.pattern);
+    FcCharSetDestroy (font->public.charset);
+    
+    /* Finally, free the font structure */
+    XftMemFree (XFT_MEM_FONT, sizeof (XftFontInt) +
+		font->num_glyphs * sizeof (XftGlyph *) +
+		font->hash_value * sizeof (XftUcsHash));
+    free (font);
+}
+
+static XftFont *
+XftFontFindNthUnref (XftDisplayInfo *info, int n)
+{
+    XftFont	*public;
+    XftFontInt	*font;
+    
+    for (public = info->fonts; public; public = font->next)
+    {
+	font = (XftFontInt*) public;
+	if (!font->ref && !n--)
+	    break;
+    }
+    return public;
+}
+
+_X_HIDDEN void
+XftFontManageMemory (Display *dpy)
+{
+    XftDisplayInfo  *info = _XftDisplayInfoGet (dpy, False);
+    XftFont	    **prev;
+    XftFont	    *public;
+    XftFontInt	    *font;
+
+    if (!info)
+	return;
+    while (info->num_unref_fonts > info->max_unref_fonts)
+    {
+	public = XftFontFindNthUnref (info, rand() % info->num_unref_fonts);
+	font = (XftFontInt *) public;
+
+	if (XftDebug () & XFT_DBG_CACHE)
+	    printf ("freeing unreferenced font %s/%d size %dx%d\n",
+		    font->info.file->file, font->info.file->id,
+		    (int) font->info.xsize >> 6, (int) font->info.ysize >> 6);
+
+	/* Unhook from display list */
+	for (prev = &info->fonts; *prev; prev = &(*(XftFontInt **) prev)->next)
+	{
+	    if (*prev == public)
+	    {
+		*prev = font->next;
+		break;
+	    }
+	}
+	/* Unhook from hash list */
+	for (prev = &info->fontHash[font->info.hash % XFT_NUM_FONT_HASH];
+	     *prev;
+	     prev = &(*(XftFontInt **) prev)->hash_next)
+	{
+	    if (*prev == public)
+	    {
+		*prev = font->hash_next;
+		break;
+	    }
+	}
+	/* Destroy the font */
+	XftFontDestroy (dpy, public);
+	--info->num_unref_fonts;
+    }
+}
+
+_X_EXPORT void
+XftFontClose (Display *dpy, XftFont *public)
+{
+    XftDisplayInfo  *info = _XftDisplayInfoGet (dpy, False);
+    XftFontInt	    *font = (XftFontInt *) public;
+    
+    if (--font->ref != 0)
+	return;
+    
+    if (info)
+    {
+	++info->num_unref_fonts;
+	XftFontManageMemory (dpy);
+    }
+    else
+    {
+	XftFontDestroy (dpy, public);
+    }
+}
+
+_X_EXPORT FcBool
+XftInitFtLibrary (void)
+{
+    if (_XftFTlibrary)
+	return FcTrue;
+    if (FT_Init_FreeType (&_XftFTlibrary))
+	return FcFalse;
+    return FcTrue;
+}
diff -Naur libXft-2.1.14.orig/src/xftglyphs.c libXft-2.1.14/src/xftglyphs.c
--- libXft-2.1.14.orig/src/xftglyphs.c	2009-01-30 00:19:09.000000000 +0100
+++ libXft-2.1.14/src/xftglyphs.c	2009-10-17 14:40:55.000000000 +0200
@@ -21,27 +21,18 @@
  */
 
 #include "xftint.h"
-#include <freetype/ftoutln.h>
 
 #if HAVE_FT_GLYPHSLOT_EMBOLDEN
 #include <freetype/ftsynth.h>
 #endif
 
-static const int    filters[3][3] = {
-    /* red */
-#if 0
-{    65538*4/7,65538*2/7,65538*1/7 },
-    /* green */
-{    65536*1/4, 65536*2/4, 65537*1/4 },
-    /* blue */
-{    65538*1/7,65538*2/7,65538*4/7 },
+#if FREETYPE_MAJOR*10000 + FREETYPE_MINOR*100 + FREETYPE_PATCH < 20202
+#error "FreeType 2.2.2 or later required to compile this version of libXft"
 #endif
-{    65538*9/13,65538*3/13,65538*1/13 },
-    /* green */
-{    65538*1/6, 65538*4/6, 65538*1/6 },
-    /* blue */
-{    65538*1/13,65538*3/13,65538*9/13 },
-};
+
+#include FT_OUTLINE_H
+#include FT_LCD_FILTER_H
+#include FT_SYNTHESIS_H
 
 /*
  * Validate the memory info for a font
@@ -69,6 +60,295 @@
 		font->glyph_memory, glyph_memory);
 }
 
+
+/* we sometimes need to convert the glyph bitmap in a FT_GlyphSlot
+ * into a different format. For example, we want to convert a
+ * FT_PIXEL_MODE_LCD or FT_PIXEL_MODE_LCD_V bitmap into a 32-bit
+ * ARGB or ABGR bitmap.
+ *
+ * this function prepares a target descriptor for this operation.
+ *
+ * input :: target bitmap descriptor. The function will set its
+ *          'width', 'rows' and 'pitch' fields, and only these
+ *
+ * slot  :: the glyph slot containing the source bitmap. this
+ *          function assumes that slot->format == FT_GLYPH_FORMAT_BITMAP
+ *
+ * mode  :: the requested final rendering mode. supported values are
+ *          MONO, NORMAL (i.e. gray), LCD and LCD_V
+ *
+ * the function returns the size in bytes of the corresponding buffer,
+ * it's up to the caller to allocate the corresponding memory block
+ * before calling _fill_xrender_bitmap
+ *
+ * it also returns -1 in case of error (e.g. incompatible arguments,
+ * like trying to convert a gray bitmap into a monochrome one)
+ */
+static int
+_compute_xrender_bitmap_size( FT_Bitmap*      target,
+                              FT_GlyphSlot    slot,
+                              FT_Render_Mode  mode )
+{
+    FT_Bitmap*  ftbit;
+    int         width, height, pitch;
+
+    if ( slot->format != FT_GLYPH_FORMAT_BITMAP )
+        return -1;
+
+    // compute the size of the final bitmap
+    ftbit  = &slot->bitmap;
+
+    width  = ftbit->width;
+    height = ftbit->rows;
+    pitch  = (width+3) & ~3;
+
+    switch ( ftbit->pixel_mode )
+    {
+    case FT_PIXEL_MODE_MONO:
+        if ( mode == FT_RENDER_MODE_MONO )
+        {
+            pitch = (((width+31) & ~31) >> 3);
+            break;
+        }
+        /* fall-through */
+
+    case FT_PIXEL_MODE_GRAY:
+        if ( mode == FT_RENDER_MODE_LCD   ||
+             mode == FT_RENDER_MODE_LCD_V )
+        {
+          /* each pixel is replicated into a 32-bit ARGB value */
+          pitch = width*4;
+        }
+        break;
+
+    case FT_PIXEL_MODE_LCD:
+        if ( mode != FT_RENDER_MODE_LCD )
+            return -1;
+
+        /* horz pixel triplets are packed into 32-bit ARGB values */
+        width   /= 3;
+        pitch    = width*4;
+        break;
+
+    case FT_PIXEL_MODE_LCD_V:
+        if ( mode != FT_RENDER_MODE_LCD_V )
+            return -1;
+
+        /* vert pixel triplets are packed into 32-bit ARGB values */
+        height  /= 3;
+        pitch    = width*4;
+        break;
+
+    default:  /* unsupported source format */
+        return -1;
+    }
+
+    target->width  = width;
+    target->rows   = height;
+    target->pitch  = pitch;
+    target->buffer = NULL;
+
+    return pitch * height;
+}
+
+/* this functions converts the glyph bitmap found in a FT_GlyphSlot
+ * into a different format (see _compute_xrender_bitmap_size)
+ *
+ * you should call this function after _compute_xrender_bitmap_size
+ *
+ * target :: target bitmap descriptor. Note that its 'buffer' pointer
+ *           must point to memory allocated by the caller
+ *
+ * slot   :: the glyph slot containing the source bitmap
+ *
+ * mode   :: the requested final rendering mode
+ *
+ * bgr    :: boolean, set if BGR or VBGR pixel ordering is needed
+ */
+static void
+_fill_xrender_bitmap( FT_Bitmap*      target,
+                      FT_GlyphSlot    slot,
+                      FT_Render_Mode  mode,
+                      int             bgr )
+{
+    FT_Bitmap*   ftbit = &slot->bitmap;
+
+    {
+        unsigned char*   srcLine   = ftbit->buffer;
+        unsigned char*   dstLine   = target->buffer;
+        int              src_pitch = ftbit->pitch;
+        int              width     = target->width;
+        int              height    = target->rows;
+        int              pitch     = target->pitch;
+        int              subpixel;
+        int              h;
+
+        subpixel = ( mode == FT_RENDER_MODE_LCD ||
+                     mode == FT_RENDER_MODE_LCD_V );
+
+        if ( src_pitch < 0 )
+          srcLine -= src_pitch*(ftbit->rows-1);
+
+        switch ( ftbit->pixel_mode )
+        {
+        case FT_PIXEL_MODE_MONO:
+            if ( subpixel )  /* convert mono to ARGB32 values */
+            {
+                for ( h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch )
+                {
+                    int  x;
+
+                    for ( x = 0; x < width; x++ )
+                    {
+                        if ( srcLine[(x >> 3)] & (0x80 >> (x & 7)) )
+                            ((unsigned int*)dstLine)[x] = 0xffffffffU;
+                    }
+                }
+            }
+            else if ( mode == FT_RENDER_MODE_NORMAL )  /* convert mono to 8-bit gray */
+            {
+                for ( h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch )
+                {
+                    int  x;
+
+                    for ( x = 0; x < width; x++ )
+                    {
+                        if ( srcLine[(x >> 3)] & (0x80 >> (x & 7)) )
+                            dstLine[x] = 0xff;
+                    }
+                }
+            }
+            else  /* copy mono to mono */
+            {
+                int  bytes = (width+7) >> 3;
+
+                for ( h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch )
+                    memcpy( dstLine, srcLine, bytes );
+            }
+            break;
+
+        case FT_PIXEL_MODE_GRAY:
+            if ( subpixel )  /* convert gray to ARGB32 values */
+            {
+                for ( h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch )
+                {
+                    int            x;
+                    unsigned int*  dst = (unsigned int*)dstLine;
+
+                    for ( x = 0; x < width; x++ )
+                    {
+                        unsigned int  pix = srcLine[x];
+
+                        pix |= (pix << 8);
+                        pix |= (pix << 16);
+
+                        dst[x] = pix;
+                    }
+                }
+            }
+            else  /* copy gray into gray */
+            {
+                for ( h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch )
+                    memcpy( dstLine, srcLine, width );
+            }
+            break;
+
+        case FT_PIXEL_MODE_LCD:
+            if ( !bgr )
+            {
+                /* convert horizontal RGB into ARGB32 */
+                for ( h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch )
+                {
+                    int            x;
+                    unsigned char* src = srcLine;
+                    unsigned int*  dst = (unsigned int*)dstLine;
+
+                    for ( x = 0; x < width; x++, src += 3 )
+                    {
+                        unsigned int  pix;
+
+                        pix = ((unsigned int)src[0] << 16) |
+                              ((unsigned int)src[1] <<  8) |
+                              ((unsigned int)src[2]      ) |
+                              ((unsigned int)src[1] << 24) ;
+
+                        dst[x] = pix;
+                    }
+                }
+            }
+            else
+            {
+                /* convert horizontal BGR into ARGB32 */
+                for ( h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch )
+                {
+                    int            x;
+                    unsigned char* src = srcLine;
+                    unsigned int*  dst = (unsigned int*)dstLine;
+
+                    for ( x = 0; x < width; x++, src += 3 )
+                    {
+                        unsigned int  pix;
+
+                        pix = ((unsigned int)src[2] << 16) |
+                              ((unsigned int)src[1] <<  8) |
+                              ((unsigned int)src[0]      ) |
+                              ((unsigned int)src[1] << 24) ;
+
+                        dst[x] = pix;
+                    }
+                }
+            }
+            break;
+
+        default:  /* FT_PIXEL_MODE_LCD_V */
+            /* convert vertical RGB into ARGB32 */
+            if ( !bgr )
+            {
+                for ( h = height; h > 0; h--, srcLine += 3*src_pitch, dstLine += pitch )
+                {
+                    int            x;
+                    unsigned char* src = srcLine;
+                    unsigned int*  dst = (unsigned int*)dstLine;
+
+                    for ( x = 0; x < width; x++, src += 1 )
+                    {
+                        unsigned int  pix;
+
+                        pix = ((unsigned int)src[0]           << 16) |
+                              ((unsigned int)src[src_pitch]   <<  8) |
+                              ((unsigned int)src[src_pitch*2]      ) |
+                              ((unsigned int)src[src_pitch]   << 24) ;
+
+                        dst[x] = pix;
+                    }
+                }
+            }
+            else
+            {
+                for ( h = height; h > 0; h--, srcLine += 3*src_pitch, dstLine += pitch )
+                {
+                    int            x;
+                    unsigned char* src = srcLine;
+                    unsigned int*  dst = (unsigned int*)dstLine;
+
+                    for ( x = 0; x < width; x++, src += 1 )
+                    {
+                        unsigned int  pix;
+
+                        pix = ((unsigned int)src[src_pitch*2] << 16) |
+                              ((unsigned int)src[src_pitch]   <<  8) |
+                              ((unsigned int)src[0]                ) |
+                              ((unsigned int)src[src_pitch]   << 24) ;
+
+                        dst[x] = pix;
+                    }
+                }
+            }
+        }
+    }
+}
+
+
 _X_EXPORT void
 XftFontLoadGlyphs (Display	    *dpy,
 		   XftFont	    *pub,
@@ -87,20 +367,14 @@
     unsigned char   *bufBitmap = bufLocal;
     int		    bufSize = sizeof (bufLocal);
     int		    size, pitch;
-    unsigned char   bufLocalRgba[4096];
-    unsigned char   *bufBitmapRgba = bufLocalRgba;
-    int		    bufSizeRgba = sizeof (bufLocalRgba);
-    int		    sizergba, pitchrgba, widthrgba;
     int		    width;
     int		    height;
     int		    left, right, top, bottom;
-    int		    hmul = 1;
-    int		    vmul = 1;
-    FT_Bitmap	    ftbit;
-    FT_Matrix	    matrix;
+    FT_Bitmap*	    ftbit;
+    FT_Bitmap       local;
     FT_Vector	    vector;
-    Bool	    subpixel = False;
     FT_Face	    face;
+    FT_Render_Mode  mode = FT_RENDER_MODE_MONO;
 
     if (!info)
 	return;
@@ -110,24 +384,19 @@
     if (!face)
 	return;
 
-    matrix.xx = matrix.yy = 0x10000L;
-    matrix.xy = matrix.yx = 0;
-
     if (font->info.antialias)
     {
 	switch (font->info.rgba) {
 	case FC_RGBA_RGB:
 	case FC_RGBA_BGR:
-	    matrix.xx *= 3;
-	    subpixel = True;
-	    hmul = 3;
+	    mode = FT_RENDER_MODE_LCD;
 	    break;
 	case FC_RGBA_VRGB:
 	case FC_RGBA_VBGR:
-	    matrix.yy *= 3;
-	    vmul = 3;
-	    subpixel = True;
+            mode = FT_RENDER_MODE_LCD_V;
 	    break;
+        default:
+            mode = FT_RENDER_MODE_NORMAL;
 	}
     }
 
@@ -148,7 +417,10 @@
 	if (xftg->glyph_memory)
 	    continue;
 	
+        FT_Library_SetLcdFilter( _XftFTlibrary, font->info.lcd_filter);
+
 	error = FT_Load_Glyph (face, glyphindex, font->info.load_flags);
+
 	if (error)
 	{
 	    /*
@@ -181,7 +453,7 @@
 	/*
 	 * Compute glyph metrics from FreeType information
 	 */
-	if(font->info.transform && glyphslot->format != ft_glyph_format_bitmap) 
+	if(font->info.transform && glyphslot->format != FT_GLYPH_FORMAT_BITMAP)
 	{
 	    /*
 	     * calculate the true width by transforming all four corners.
@@ -260,17 +532,14 @@
 	    }
 	}
 
-	if (font->info.antialias)
-	    pitch = (width * hmul + 3) & ~3;
-	else
-	    pitch = ((width + 31) & ~31) >> 3;
-
-	size = pitch * height * vmul;
+        if ( glyphslot->format != FT_GLYPH_FORMAT_BITMAP )
+        {
+            error = FT_Render_Glyph( face->glyph, mode );
+            if (error)
+                continue;
+        }
 
-	xftg->metrics.width = width;
-	xftg->metrics.height = height;
-	xftg->metrics.x = -TRUNC(left);
-	xftg->metrics.y = TRUNC(top);
+        FT_Library_SetLcdFilter( _XftFTlibrary, FT_LCD_FILTER_NONE );
 
 	if (font->info.spacing >= FC_MONO)
 	{
@@ -310,103 +579,13 @@
 	    xftg->metrics.yOff = -TRUNC(ROUND(glyphslot->advance.y));
 	}
 	
-	/*
-	 * If the glyph is relatively large (> 1% of server memory),
-	 * don't send it until necessary
-	 */
-	if (!need_bitmaps && size > info->max_glyph_memory / 100)
-	    continue;
 	
-	/*
-	 * Make sure there's enough buffer space for the glyph
-	 */
-	if (size > bufSize)
-	{
-	    if (bufBitmap != bufLocal)
-		free (bufBitmap);
-	    bufBitmap = (unsigned char *) malloc (size);
-	    if (!bufBitmap)
-		continue;
-	    bufSize = size;
-	}
-	memset (bufBitmap, 0, size);
-
-	/*
-	 * Rasterize into the local buffer
-	 */
-	switch (glyphslot->format) {
-	case ft_glyph_format_outline:
-	    ftbit.width      = width * hmul;
-	    ftbit.rows       = height * vmul;
-	    ftbit.pitch      = pitch;
-	    if (font->info.antialias)
-		ftbit.pixel_mode = ft_pixel_mode_grays;
-	    else
-		ftbit.pixel_mode = ft_pixel_mode_mono;
-	    
-	    ftbit.buffer     = bufBitmap;
-	    
-	    if (subpixel)
-		FT_Outline_Transform (&glyphslot->outline, &matrix);
-
-	    FT_Outline_Translate ( &glyphslot->outline, -left*hmul, -bottom*vmul );
+        // compute the size of the final bitmap
+        ftbit  = &glyphslot->bitmap;
 
-	    FT_Outline_Get_Bitmap( _XftFTlibrary, &glyphslot->outline, &ftbit );
-	    break;
-	case ft_glyph_format_bitmap:
-	    if (font->info.antialias)
-	    {
-		unsigned char	*srcLine, *dstLine;
-		int		height;
-		int		x;
-		int	    h, v;
-
-		srcLine = glyphslot->bitmap.buffer;
-		dstLine = bufBitmap;
-		height = glyphslot->bitmap.rows;
-		while (height--)
-		{
-		    for (x = 0; x < glyphslot->bitmap.width; x++)
-		    {
-			/* always MSB bitmaps */
-			unsigned char	a = ((srcLine[x >> 3] & (0x80 >> (x & 7))) ?
-					     0xff : 0x00);
-			if (subpixel)
-			{
-			    for (v = 0; v < vmul; v++)
-				for (h = 0; h < hmul; h++)
-				    dstLine[v * pitch + x*hmul + h] = a;
-			}
-			else
-			    dstLine[x] = a;
-		    }
-		    dstLine += pitch * vmul;
-		    srcLine += glyphslot->bitmap.pitch;
-		}
-	    }
-	    else
-	    {
-		unsigned char	*srcLine, *dstLine;
-		int		h, bytes;
-
-		srcLine = glyphslot->bitmap.buffer;
-		dstLine = bufBitmap;
-		h = glyphslot->bitmap.rows;
-		bytes = (glyphslot->bitmap.width + 7) >> 3;
-		while (h--)
-		{
-		    memcpy (dstLine, srcLine, bytes);
-		    dstLine += pitch;
-		    srcLine += glyphslot->bitmap.pitch;
-		}
-	    }
-	    break;
-	default:
-	    if (XftDebug() & XFT_DBG_GLYPH)
-		printf ("glyph %d is not in a usable format\n",
-			(int) glyphindex);
-	    continue;
-	}
+        width  = ftbit->width;
+        height = ftbit->rows;
+        pitch  = (width+3) & ~3;
 	
 	if (XftDebug() & XFT_DBG_GLYPH)
 	{
@@ -423,29 +602,72 @@
 		int		x, y;
 		unsigned char	*line;
 
-		line = bufBitmap;
-		for (y = 0; y < height * vmul; y++)
+                line = ftbit->buffer;
+
+                if (ftbit->pitch < 0)
+                  line -= ftbit->pitch*(height-1);
+
+                for (y = 0; y < height; y++)
 		{
 		    if (font->info.antialias) 
 		    {
-			static char    den[] = { " .:;=+*#" };
-			for (x = 0; x < pitch; x++)
+                        static const char    den[] = { " .:;=+*#" };
+                        for (x = 0; x < width; x++)
 			    printf ("%c", den[line[x] >> 5]);
 		    }
 		    else
 		    {
-			for (x = 0; x < pitch * 8; x++)
+                        for (x = 0; x < width * 8; x++)
 			{
 			    printf ("%c", line[x>>3] & (1 << (x & 7)) ? '#' : ' ');
 			}
 		    }
 		    printf ("|\n");
-		    line += pitch;
+                    line += ftbit->pitch;
 		}
 		printf ("\n");
 	    }
 	}
 
+        size = _compute_xrender_bitmap_size( &local, glyphslot, mode );
+        if ( size < 0 )
+            continue;
+
+        xftg->metrics.width  = local.width;
+	xftg->metrics.height = local.rows;
+	xftg->metrics.x      = - glyphslot->bitmap_left;
+	xftg->metrics.y      =   glyphslot->bitmap_top;
+	    
+	    /*
+	 * If the glyph is relatively large (> 1% of server memory),
+	 * don't send it until necessary
+	     */
+	if (!need_bitmaps && size > info->max_glyph_memory / 100)
+	    continue;
+
+	/*
+	 * Make sure there's enough buffer space for the glyph
+	 */
+	if (size > bufSize)
+	    {
+	    if (bufBitmap != bufLocal)
+		free (bufBitmap);
+	    bufBitmap = (unsigned char *) malloc (size);
+	    if (!bufBitmap)
+		    continue;
+	    bufSize = size;
+	    }
+	memset (bufBitmap, 0, size);
+
+        local.buffer = bufBitmap;
+	    
+        _fill_xrender_bitmap( &local, glyphslot, mode,
+                              (font->info.rgba == FC_RGBA_BGR  ||
+                               font->info.rgba == FC_RGBA_VBGR ) );
+	/*
+	 * Copy or convert into local buffer
+	 */
+
 	/*
 	 * Use the glyph index as the wire encoding; it
 	 * might be more efficient for some locales to map
@@ -455,146 +677,55 @@
 	 */
 	glyph = (Glyph) glyphindex;
 
-	if (subpixel)
+	xftg->glyph_memory = size + sizeof (XftGlyph);
+	if (font->format)
 	{
-	    int		    x, y;
-	    unsigned char   *in_line, *out_line, *in;
-	    unsigned int    *out;
-	    unsigned int    red, green, blue;
-	    int		    rf, gf, bf;
-	    int		    s;
-	    int		    o, os;
-	    
-	    /*
-	     * Filter the glyph to soften the color fringes
-	     */
-	    widthrgba = width;
-	    pitchrgba = (widthrgba * 4 + 3) & ~3;
-	    sizergba = pitchrgba * height;
-
-	    os = 1;
-	    switch (font->info.rgba) {
-	    case FC_RGBA_VRGB:
-		os = pitch;
-	    case FC_RGBA_RGB:
-	    default:
-		rf = 0;
-		gf = 1;
-		bf = 2;
-		break;
-	    case FC_RGBA_VBGR:
-		os = pitch;
-	    case FC_RGBA_BGR:
-		bf = 0;
-		gf = 1;
-		rf = 2;
-		break;
-	    }
-	    if (sizergba > bufSizeRgba)
-	    {
-		if (bufBitmapRgba != bufLocalRgba)
-		    free (bufBitmapRgba);
-		bufBitmapRgba = (unsigned char *) malloc (sizergba);
-		if (!bufBitmapRgba)
-		    continue;
-		bufSizeRgba = sizergba;
-	    }
-	    memset (bufBitmapRgba, 0, sizergba);
-	    in_line = bufBitmap;
-	    out_line = bufBitmapRgba;
-	    for (y = 0; y < height; y++)
-	    {
-		in = in_line;
-		out = (unsigned int *) out_line;
-		in_line += pitch * vmul;
-		out_line += pitchrgba;
-		for (x = 0; x < width * hmul; x += hmul)
-		{
-		    red = green = blue = 0;
-		    o = 0;
-		    for (s = 0; s < 3; s++)
-		    {
-			red += filters[rf][s]*in[x+o];
-			green += filters[gf][s]*in[x+o];
-			blue += filters[bf][s]*in[x+o];
-			o += os;
-		    }
-		    red = red / 65536;
-		    green = green / 65536;
-		    blue = blue / 65536;
-		    *out++ = (green << 24) | (red << 16) | (green << 8) | blue;
-		}
-	    }
-	    
-	    xftg->glyph_memory = sizergba + sizeof (XftGlyph);
-	    if (font->format)
-	    {
-		if (!font->glyphset)
-		    font->glyphset = XRenderCreateGlyphSet (dpy, font->format);
-		if (ImageByteOrder (dpy) != XftNativeByteOrder ())
-		    XftSwapCARD32 ((CARD32 *) bufBitmapRgba, sizergba >> 2);
-		XRenderAddGlyphs (dpy, font->glyphset, &glyph,
-				  &xftg->metrics, 1, 
-				  (char *) bufBitmapRgba, sizergba);
-	    }
-	    else
+	    if (!font->glyphset)
+	        font->glyphset = XRenderCreateGlyphSet (dpy, font->format);
+
+            if ( mode == FT_RENDER_MODE_MONO )
 	    {
-		if (sizergba)
-		{
-		    xftg->bitmap = malloc (sizergba);
-		    if (xftg->bitmap)
-			memcpy (xftg->bitmap, bufBitmapRgba, sizergba);
-		}
-		else
-		    xftg->bitmap = NULL;
-	    }
+                /* swap bits in each byte */
+	        if (BitmapBitOrder (dpy) != MSBFirst)
+	        {
+	            unsigned char   *line;
+	            unsigned char   c;
+	            int		    i;
+
+	            line = (unsigned char *) bufBitmap;
+	            i = size;
+	            while (i--)
+	            {
+	                c = *line;
+	                c = ((c << 1) & 0xaa) | ((c >> 1) & 0x55);
+	                c = ((c << 2) & 0xcc) | ((c >> 2) & 0x33);
+	                c = ((c << 4) & 0xf0) | ((c >> 4) & 0x0f);
+	                *line++ = c;
+	            }
+	        }
+	    }
+            else if ( mode != FT_RENDER_MODE_NORMAL )
+            {
+                /* invert ARGB <=> BGRA */
+                if (ImageByteOrder (dpy) != XftNativeByteOrder ())
+                    XftSwapCARD32 ((CARD32 *) bufBitmap, size >> 2);
+            }
+	    XRenderAddGlyphs (dpy, font->glyphset, &glyph,
+	    	      &xftg->metrics, 1, 
+	    	      (char *) bufBitmap, size);
 	}
 	else
 	{
-	    xftg->glyph_memory = size + sizeof (XftGlyph);
-	    if (font->format)
+	    if (size)
 	    {
-		/*
-		 * swap bit order around; FreeType is always MSBFirst
-		 */
-		if (!font->info.antialias)
-		{
-		    if (BitmapBitOrder (dpy) != MSBFirst)
-		    {
-			unsigned char   *line;
-			unsigned char   c;
-			int		    i;
-
-			line = (unsigned char *) bufBitmap;
-			i = size;
-			while (i--)
-			{
-			    c = *line;
-			    c = ((c << 1) & 0xaa) | ((c >> 1) & 0x55);
-			    c = ((c << 2) & 0xcc) | ((c >> 2) & 0x33);
-			    c = ((c << 4) & 0xf0) | ((c >> 4) & 0x0f);
-			    *line++ = c;
-			}
-		    }
-		}
-		if (!font->glyphset)
-		    font->glyphset = XRenderCreateGlyphSet (dpy, font->format);
-		XRenderAddGlyphs (dpy, font->glyphset, &glyph,
-				  &xftg->metrics, 1, 
-				  (char *) bufBitmap, size);
+	        xftg->bitmap = malloc (size);
+	        if (xftg->bitmap)
+	    	memcpy (xftg->bitmap, bufBitmap, size);
 	    }
 	    else
-	    {
-		if (size)
-		{
-		    xftg->bitmap = malloc (size);
-		    if (xftg->bitmap)
-			memcpy (xftg->bitmap, bufBitmap, size);
-		}
-		else
-		    xftg->bitmap = NULL;
-	    }
+	        xftg->bitmap = NULL;
 	}
+
 	font->glyph_memory += xftg->glyph_memory;
 	info->glyph_memory += xftg->glyph_memory;
 	if (XftDebug() & XFT_DBG_CACHE)
@@ -605,8 +736,6 @@
     }
     if (bufBitmap != bufLocal)
 	free (bufBitmap);
-    if (bufBitmapRgba != bufLocalRgba)
-	free (bufBitmapRgba);
     XftUnlockFace (&font->public);
 }
 
diff -Naur libXft-2.1.14.orig/src/xftglyphs.c.orig libXft-2.1.14/src/xftglyphs.c.orig
--- libXft-2.1.14.orig/src/xftglyphs.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ libXft-2.1.14/src/xftglyphs.c.orig	2009-01-30 00:19:09.000000000 +0100
@@ -0,0 +1,827 @@
+/*
+ * Copyright Â© 2000 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "xftint.h"
+#include <freetype/ftoutln.h>
+
+#if HAVE_FT_GLYPHSLOT_EMBOLDEN
+#include <freetype/ftsynth.h>
+#endif
+
+static const int    filters[3][3] = {
+    /* red */
+#if 0
+{    65538*4/7,65538*2/7,65538*1/7 },
+    /* green */
+{    65536*1/4, 65536*2/4, 65537*1/4 },
+    /* blue */
+{    65538*1/7,65538*2/7,65538*4/7 },
+#endif
+{    65538*9/13,65538*3/13,65538*1/13 },
+    /* green */
+{    65538*1/6, 65538*4/6, 65538*1/6 },
+    /* blue */
+{    65538*1/13,65538*3/13,65538*9/13 },
+};
+
+/*
+ * Validate the memory info for a font
+ */
+
+static void
+_XftFontValidateMemory (Display *dpy, XftFont *public)
+{
+    XftFontInt	    *font = (XftFontInt *) public;
+    unsigned long   glyph_memory;
+    FT_UInt	    glyphindex;
+    XftGlyph	    *xftg;
+
+    glyph_memory = 0;
+    for (glyphindex = 0; glyphindex < font->num_glyphs; glyphindex++)
+    {
+	xftg = font->glyphs[glyphindex];
+	if (xftg)
+	{
+	    glyph_memory += xftg->glyph_memory;
+	}
+    }
+    if (glyph_memory != font->glyph_memory)
+	printf ("Font glyph cache incorrect has %ld bytes, should have %ld\n",
+		font->glyph_memory, glyph_memory);
+}
+
+_X_EXPORT void
+XftFontLoadGlyphs (Display	    *dpy,
+		   XftFont	    *pub,
+		   FcBool	    need_bitmaps,
+		   _Xconst FT_UInt  *glyphs,
+		   int		    nglyph)
+{
+    XftDisplayInfo  *info = _XftDisplayInfoGet (dpy, True);
+    XftFontInt	    *font = (XftFontInt *) pub;
+    FT_Error	    error;
+    FT_UInt	    glyphindex;
+    FT_GlyphSlot    glyphslot;
+    XftGlyph	    *xftg;
+    Glyph	    glyph;
+    unsigned char   bufLocal[4096];
+    unsigned char   *bufBitmap = bufLocal;
+    int		    bufSize = sizeof (bufLocal);
+    int		    size, pitch;
+    unsigned char   bufLocalRgba[4096];
+    unsigned char   *bufBitmapRgba = bufLocalRgba;
+    int		    bufSizeRgba = sizeof (bufLocalRgba);
+    int		    sizergba, pitchrgba, widthrgba;
+    int		    width;
+    int		    height;
+    int		    left, right, top, bottom;
+    int		    hmul = 1;
+    int		    vmul = 1;
+    FT_Bitmap	    ftbit;
+    FT_Matrix	    matrix;
+    FT_Vector	    vector;
+    Bool	    subpixel = False;
+    FT_Face	    face;
+
+    if (!info)
+	return;
+
+    face = XftLockFace (&font->public);
+    
+    if (!face)
+	return;
+
+    matrix.xx = matrix.yy = 0x10000L;
+    matrix.xy = matrix.yx = 0;
+
+    if (font->info.antialias)
+    {
+	switch (font->info.rgba) {
+	case FC_RGBA_RGB:
+	case FC_RGBA_BGR:
+	    matrix.xx *= 3;
+	    subpixel = True;
+	    hmul = 3;
+	    break;
+	case FC_RGBA_VRGB:
+	case FC_RGBA_VBGR:
+	    matrix.yy *= 3;
+	    vmul = 3;
+	    subpixel = True;
+	    break;
+	}
+    }
+
+    while (nglyph--)
+    {
+	glyphindex = *glyphs++;
+	xftg = font->glyphs[glyphindex];
+	if (!xftg)
+	    continue;
+	
+	if (XftDebug() & XFT_DBG_CACHE)
+	    _XftFontValidateMemory (dpy, pub);
+	/*
+	 * Check to see if this glyph has just been loaded,
+	 * this happens when drawing the same glyph twice
+	 * in a single string
+	 */
+	if (xftg->glyph_memory)
+	    continue;
+	
+	error = FT_Load_Glyph (face, glyphindex, font->info.load_flags);
+	if (error)
+	{
+	    /*
+	     * If anti-aliasing or transforming glyphs and
+	     * no outline version exists, fallback to the
+	     * bitmap and let things look bad instead of
+	     * missing the glyph
+	     */
+	    if (font->info.load_flags & FT_LOAD_NO_BITMAP)
+		error = FT_Load_Glyph (face, glyphindex,
+				       font->info.load_flags & ~FT_LOAD_NO_BITMAP);
+	    if (error)
+		continue;
+	}
+
+#define FLOOR(x)    ((x) & -64)
+#define CEIL(x)	    (((x)+63) & -64)
+#define TRUNC(x)    ((x) >> 6)
+#define ROUND(x)    (((x)+32) & -64)
+		
+	glyphslot = face->glyph;
+
+#if HAVE_FT_GLYPHSLOT_EMBOLDEN
+	/*
+	 * Embolden if required
+	 */
+	if (font->info.embolden) FT_GlyphSlot_Embolden(glyphslot);
+#endif
+
+	/*
+	 * Compute glyph metrics from FreeType information
+	 */
+	if(font->info.transform && glyphslot->format != ft_glyph_format_bitmap) 
+	{
+	    /*
+	     * calculate the true width by transforming all four corners.
+	     */
+	    int xc, yc;
+	    left = right = top = bottom = 0;
+	    for(xc = 0; xc <= 1; xc ++) {
+		for(yc = 0; yc <= 1; yc++) {
+		    vector.x = glyphslot->metrics.horiBearingX + xc * glyphslot->metrics.width;
+		    vector.y = glyphslot->metrics.horiBearingY - yc * glyphslot->metrics.height;
+		    FT_Vector_Transform(&vector, &font->info.matrix);   
+		    if (XftDebug() & XFT_DBG_GLYPH)
+			printf("Trans %d %d: %d %d\n", (int) xc, (int) yc, 
+			       (int) vector.x, (int) vector.y);
+		    if(xc == 0 && yc == 0) {
+			left = right = vector.x;
+			top = bottom = vector.y;
+		    } else {
+			if(left > vector.x) left = vector.x;
+			if(right < vector.x) right = vector.x;
+			if(bottom > vector.y) bottom = vector.y;
+			if(top < vector.y) top = vector.y;
+		    }
+
+		}
+	    }
+	    left = FLOOR(left);
+	    right = CEIL(right);
+	    bottom = FLOOR(bottom);
+	    top = CEIL(top);
+
+	} else {
+	    left  = FLOOR( glyphslot->metrics.horiBearingX );
+	    right = CEIL( glyphslot->metrics.horiBearingX + glyphslot->metrics.width );
+
+	    top    = CEIL( glyphslot->metrics.horiBearingY );
+	    bottom = FLOOR( glyphslot->metrics.horiBearingY - glyphslot->metrics.height );
+	}
+
+	width = TRUNC(right - left);
+	height = TRUNC( top - bottom );
+
+	/*
+	 * Clip charcell glyphs to the bounding box
+	 * XXX transformed?
+	 */
+	if (font->info.spacing >= FC_CHARCELL && !font->info.transform)
+	{
+	    if (font->info.load_flags & FT_LOAD_VERTICAL_LAYOUT)
+	    {
+		if (TRUNC(bottom) > font->public.max_advance_width)
+		{
+		    int adjust;
+    
+		    adjust = bottom - (font->public.max_advance_width << 6);
+		    if (adjust > top)
+			adjust = top;
+		    top -= adjust;
+		    bottom -= adjust;
+		    height = font->public.max_advance_width;
+		}
+	    }
+	    else
+	    {
+		if (TRUNC(right) > font->public.max_advance_width)
+		{
+		    int adjust;
+    
+		    adjust = right - (font->public.max_advance_width << 6);
+		    if (adjust > left)
+			adjust = left;
+		    left -= adjust;
+		    right -= adjust;
+		    width = font->public.max_advance_width;
+		}
+	    }
+	}
+
+	if (font->info.antialias)
+	    pitch = (width * hmul + 3) & ~3;
+	else
+	    pitch = ((width + 31) & ~31) >> 3;
+
+	size = pitch * height * vmul;
+
+	xftg->metrics.width = width;
+	xftg->metrics.height = height;
+	xftg->metrics.x = -TRUNC(left);
+	xftg->metrics.y = TRUNC(top);
+
+	if (font->info.spacing >= FC_MONO)
+	{
+	    if (font->info.transform)
+	    {
+		if (font->info.load_flags & FT_LOAD_VERTICAL_LAYOUT)
+		{
+		    vector.x = 0;
+		    vector.y = -face->size->metrics.max_advance;
+		}
+		else
+		{
+		    vector.x = face->size->metrics.max_advance;
+		    vector.y = 0;
+		}
+		FT_Vector_Transform (&vector, &font->info.matrix);
+		xftg->metrics.xOff = vector.x >> 6;
+		xftg->metrics.yOff = -(vector.y >> 6);
+	    }
+	    else
+	    {
+		if (font->info.load_flags & FT_LOAD_VERTICAL_LAYOUT)
+		{
+		    xftg->metrics.xOff = 0;
+		    xftg->metrics.yOff = -font->public.max_advance_width;
+		}
+		else
+		{
+		    xftg->metrics.xOff = font->public.max_advance_width;
+		    xftg->metrics.yOff = 0;
+		}
+	    }
+	}
+	else
+	{
+	    xftg->metrics.xOff = TRUNC(ROUND(glyphslot->advance.x));
+	    xftg->metrics.yOff = -TRUNC(ROUND(glyphslot->advance.y));
+	}
+	
+	/*
+	 * If the glyph is relatively large (> 1% of server memory),
+	 * don't send it until necessary
+	 */
+	if (!need_bitmaps && size > info->max_glyph_memory / 100)
+	    continue;
+	
+	/*
+	 * Make sure there's enough buffer space for the glyph
+	 */
+	if (size > bufSize)
+	{
+	    if (bufBitmap != bufLocal)
+		free (bufBitmap);
+	    bufBitmap = (unsigned char *) malloc (size);
+	    if (!bufBitmap)
+		continue;
+	    bufSize = size;
+	}
+	memset (bufBitmap, 0, size);
+
+	/*
+	 * Rasterize into the local buffer
+	 */
+	switch (glyphslot->format) {
+	case ft_glyph_format_outline:
+	    ftbit.width      = width * hmul;
+	    ftbit.rows       = height * vmul;
+	    ftbit.pitch      = pitch;
+	    if (font->info.antialias)
+		ftbit.pixel_mode = ft_pixel_mode_grays;
+	    else
+		ftbit.pixel_mode = ft_pixel_mode_mono;
+	    
+	    ftbit.buffer     = bufBitmap;
+	    
+	    if (subpixel)
+		FT_Outline_Transform (&glyphslot->outline, &matrix);
+
+	    FT_Outline_Translate ( &glyphslot->outline, -left*hmul, -bottom*vmul );
+
+	    FT_Outline_Get_Bitmap( _XftFTlibrary, &glyphslot->outline, &ftbit );
+	    break;
+	case ft_glyph_format_bitmap:
+	    if (font->info.antialias)
+	    {
+		unsigned char	*srcLine, *dstLine;
+		int		height;
+		int		x;
+		int	    h, v;
+
+		srcLine = glyphslot->bitmap.buffer;
+		dstLine = bufBitmap;
+		height = glyphslot->bitmap.rows;
+		while (height--)
+		{
+		    for (x = 0; x < glyphslot->bitmap.width; x++)
+		    {
+			/* always MSB bitmaps */
+			unsigned char	a = ((srcLine[x >> 3] & (0x80 >> (x & 7))) ?
+					     0xff : 0x00);
+			if (subpixel)
+			{
+			    for (v = 0; v < vmul; v++)
+				for (h = 0; h < hmul; h++)
+				    dstLine[v * pitch + x*hmul + h] = a;
+			}
+			else
+			    dstLine[x] = a;
+		    }
+		    dstLine += pitch * vmul;
+		    srcLine += glyphslot->bitmap.pitch;
+		}
+	    }
+	    else
+	    {
+		unsigned char	*srcLine, *dstLine;
+		int		h, bytes;
+
+		srcLine = glyphslot->bitmap.buffer;
+		dstLine = bufBitmap;
+		h = glyphslot->bitmap.rows;
+		bytes = (glyphslot->bitmap.width + 7) >> 3;
+		while (h--)
+		{
+		    memcpy (dstLine, srcLine, bytes);
+		    dstLine += pitch;
+		    srcLine += glyphslot->bitmap.pitch;
+		}
+	    }
+	    break;
+	default:
+	    if (XftDebug() & XFT_DBG_GLYPH)
+		printf ("glyph %d is not in a usable format\n",
+			(int) glyphindex);
+	    continue;
+	}
+	
+	if (XftDebug() & XFT_DBG_GLYPH)
+	{
+	    printf ("glyph %d:\n", (int) glyphindex);
+	    printf (" xywh (%d %d %d %d), trans (%d %d %d %d) wh (%d %d)\n",
+		    (int) glyphslot->metrics.horiBearingX,
+		    (int) glyphslot->metrics.horiBearingY,
+		    (int) glyphslot->metrics.width,
+		    (int) glyphslot->metrics.height,
+		    left, right, top, bottom,
+		    width, height);
+	    if (XftDebug() & XFT_DBG_GLYPHV)
+	    {
+		int		x, y;
+		unsigned char	*line;
+
+		line = bufBitmap;
+		for (y = 0; y < height * vmul; y++)
+		{
+		    if (font->info.antialias) 
+		    {
+			static char    den[] = { " .:;=+*#" };
+			for (x = 0; x < pitch; x++)
+			    printf ("%c", den[line[x] >> 5]);
+		    }
+		    else
+		    {
+			for (x = 0; x < pitch * 8; x++)
+			{
+			    printf ("%c", line[x>>3] & (1 << (x & 7)) ? '#' : ' ');
+			}
+		    }
+		    printf ("|\n");
+		    line += pitch;
+		}
+		printf ("\n");
+	    }
+	}
+
+	/*
+	 * Use the glyph index as the wire encoding; it
+	 * might be more efficient for some locales to map
+	 * these by first usage to smaller values, but that
+	 * would require persistently storing the map when
+	 * glyphs were freed.
+	 */
+	glyph = (Glyph) glyphindex;
+
+	if (subpixel)
+	{
+	    int		    x, y;
+	    unsigned char   *in_line, *out_line, *in;
+	    unsigned int    *out;
+	    unsigned int    red, green, blue;
+	    int		    rf, gf, bf;
+	    int		    s;
+	    int		    o, os;
+	    
+	    /*
+	     * Filter the glyph to soften the color fringes
+	     */
+	    widthrgba = width;
+	    pitchrgba = (widthrgba * 4 + 3) & ~3;
+	    sizergba = pitchrgba * height;
+
+	    os = 1;
+	    switch (font->info.rgba) {
+	    case FC_RGBA_VRGB:
+		os = pitch;
+	    case FC_RGBA_RGB:
+	    default:
+		rf = 0;
+		gf = 1;
+		bf = 2;
+		break;
+	    case FC_RGBA_VBGR:
+		os = pitch;
+	    case FC_RGBA_BGR:
+		bf = 0;
+		gf = 1;
+		rf = 2;
+		break;
+	    }
+	    if (sizergba > bufSizeRgba)
+	    {
+		if (bufBitmapRgba != bufLocalRgba)
+		    free (bufBitmapRgba);
+		bufBitmapRgba = (unsigned char *) malloc (sizergba);
+		if (!bufBitmapRgba)
+		    continue;
+		bufSizeRgba = sizergba;
+	    }
+	    memset (bufBitmapRgba, 0, sizergba);
+	    in_line = bufBitmap;
+	    out_line = bufBitmapRgba;
+	    for (y = 0; y < height; y++)
+	    {
+		in = in_line;
+		out = (unsigned int *) out_line;
+		in_line += pitch * vmul;
+		out_line += pitchrgba;
+		for (x = 0; x < width * hmul; x += hmul)
+		{
+		    red = green = blue = 0;
+		    o = 0;
+		    for (s = 0; s < 3; s++)
+		    {
+			red += filters[rf][s]*in[x+o];
+			green += filters[gf][s]*in[x+o];
+			blue += filters[bf][s]*in[x+o];
+			o += os;
+		    }
+		    red = red / 65536;
+		    green = green / 65536;
+		    blue = blue / 65536;
+		    *out++ = (green << 24) | (red << 16) | (green << 8) | blue;
+		}
+	    }
+	    
+	    xftg->glyph_memory = sizergba + sizeof (XftGlyph);
+	    if (font->format)
+	    {
+		if (!font->glyphset)
+		    font->glyphset = XRenderCreateGlyphSet (dpy, font->format);
+		if (ImageByteOrder (dpy) != XftNativeByteOrder ())
+		    XftSwapCARD32 ((CARD32 *) bufBitmapRgba, sizergba >> 2);
+		XRenderAddGlyphs (dpy, font->glyphset, &glyph,
+				  &xftg->metrics, 1, 
+				  (char *) bufBitmapRgba, sizergba);
+	    }
+	    else
+	    {
+		if (sizergba)
+		{
+		    xftg->bitmap = malloc (sizergba);
+		    if (xftg->bitmap)
+			memcpy (xftg->bitmap, bufBitmapRgba, sizergba);
+		}
+		else
+		    xftg->bitmap = NULL;
+	    }
+	}
+	else
+	{
+	    xftg->glyph_memory = size + sizeof (XftGlyph);
+	    if (font->format)
+	    {
+		/*
+		 * swap bit order around; FreeType is always MSBFirst
+		 */
+		if (!font->info.antialias)
+		{
+		    if (BitmapBitOrder (dpy) != MSBFirst)
+		    {
+			unsigned char   *line;
+			unsigned char   c;
+			int		    i;
+
+			line = (unsigned char *) bufBitmap;
+			i = size;
+			while (i--)
+			{
+			    c = *line;
+			    c = ((c << 1) & 0xaa) | ((c >> 1) & 0x55);
+			    c = ((c << 2) & 0xcc) | ((c >> 2) & 0x33);
+			    c = ((c << 4) & 0xf0) | ((c >> 4) & 0x0f);
+			    *line++ = c;
+			}
+		    }
+		}
+		if (!font->glyphset)
+		    font->glyphset = XRenderCreateGlyphSet (dpy, font->format);
+		XRenderAddGlyphs (dpy, font->glyphset, &glyph,
+				  &xftg->metrics, 1, 
+				  (char *) bufBitmap, size);
+	    }
+	    else
+	    {
+		if (size)
+		{
+		    xftg->bitmap = malloc (size);
+		    if (xftg->bitmap)
+			memcpy (xftg->bitmap, bufBitmap, size);
+		}
+		else
+		    xftg->bitmap = NULL;
+	    }
+	}
+	font->glyph_memory += xftg->glyph_memory;
+	info->glyph_memory += xftg->glyph_memory;
+	if (XftDebug() & XFT_DBG_CACHE)
+	    _XftFontValidateMemory (dpy, pub);
+	if (XftDebug() & XFT_DBG_CACHEV)
+	    printf ("Caching glyph 0x%x size %ld\n", glyphindex,
+		    xftg->glyph_memory);
+    }
+    if (bufBitmap != bufLocal)
+	free (bufBitmap);
+    if (bufBitmapRgba != bufLocalRgba)
+	free (bufBitmapRgba);
+    XftUnlockFace (&font->public);
+}
+
+_X_EXPORT void
+XftFontUnloadGlyphs (Display		*dpy,
+		     XftFont		*pub,
+		     _Xconst FT_UInt	*glyphs,
+		     int		nglyph)
+{
+    XftDisplayInfo  *info = _XftDisplayInfoGet (dpy, False);
+    XftFontInt	    *font = (XftFontInt *) pub;
+    XftGlyph	    *xftg;
+    FT_UInt	    glyphindex;
+    Glyph	    glyphBuf[1024];
+    int		    nused;
+    
+    nused = 0;
+    while (nglyph--)
+    {
+	glyphindex = *glyphs++;
+	xftg = font->glyphs[glyphindex];
+	if (!xftg)
+	    continue;
+	if (xftg->glyph_memory)
+	{
+	    if (font->format)
+	    {
+		if (font->glyphset)
+		{
+		    glyphBuf[nused++] = (Glyph) glyphindex;
+		    if (nused == sizeof (glyphBuf) / sizeof (glyphBuf[0]))
+		    {
+			XRenderFreeGlyphs (dpy, font->glyphset, glyphBuf, nused);
+			nused = 0;
+		    }
+		}
+	    }
+	    else
+	    {
+		if (xftg->bitmap)
+		    free (xftg->bitmap);
+	    }
+	    font->glyph_memory -= xftg->glyph_memory;
+	    if (info)
+		info->glyph_memory -= xftg->glyph_memory;
+	}
+	free (xftg);
+	XftMemFree (XFT_MEM_GLYPH, sizeof (XftGlyph));
+	font->glyphs[glyphindex] = NULL;
+    }    
+    if (font->glyphset && nused)
+	XRenderFreeGlyphs (dpy, font->glyphset, glyphBuf, nused);
+}
+
+_X_EXPORT FcBool
+XftFontCheckGlyph (Display	*dpy,
+		   XftFont	*pub,
+		   FcBool	need_bitmaps,
+		   FT_UInt	glyph,
+		   FT_UInt	*missing,
+		   int		*nmissing)
+{
+    XftFontInt	    *font = (XftFontInt *) pub;
+    XftGlyph	    *xftg;
+    int		    n;
+    
+    if (glyph >= font->num_glyphs)
+	return FcFalse;
+    xftg = font->glyphs[glyph];
+    if (!xftg || (need_bitmaps && !xftg->glyph_memory))
+    {
+	if (!xftg)
+	{
+	    xftg = (XftGlyph *) malloc (sizeof (XftGlyph));
+	    if (!xftg)
+		return FcFalse;
+	    XftMemAlloc (XFT_MEM_GLYPH, sizeof (XftGlyph));
+	    xftg->bitmap = NULL;
+	    xftg->glyph_memory = 0;
+	    font->glyphs[glyph] = xftg;
+	}
+	n = *nmissing;
+	missing[n++] = glyph;
+	if (n == XFT_NMISSING)
+	{
+	    XftFontLoadGlyphs (dpy, pub, need_bitmaps, missing, n);
+	    n = 0;
+	}
+	*nmissing = n;
+	return FcTrue;
+    }
+    else
+	return FcFalse;
+}
+
+_X_EXPORT FcBool
+XftCharExists (Display	    *dpy,
+	       XftFont	    *pub,
+	       FcChar32    ucs4)
+{
+    if (pub->charset)
+	return FcCharSetHasChar (pub->charset, ucs4);
+    return FcFalse;
+}
+
+#define Missing	    ((FT_UInt) ~0)
+
+_X_EXPORT FT_UInt
+XftCharIndex (Display	    *dpy, 
+	      XftFont	    *pub,
+	      FcChar32	    ucs4)
+{
+    XftFontInt	*font = (XftFontInt *) pub;
+    FcChar32	ent, offset;
+    FT_Face	face;
+    
+    if (!font->hash_value)
+	return 0;
+
+    ent = ucs4 % font->hash_value;
+    offset = 0;
+    while (font->hash_table[ent].ucs4 != ucs4)
+    {
+	if (font->hash_table[ent].ucs4 == (FcChar32) ~0)
+	{
+	    if (!XftCharExists (dpy, pub, ucs4))
+		return 0;
+	    face  = XftLockFace (pub);
+	    if (!face)
+		return 0;
+	    font->hash_table[ent].ucs4 = ucs4;
+	    font->hash_table[ent].glyph = FcFreeTypeCharIndex (face, ucs4);
+	    XftUnlockFace (pub);
+	    break;
+	}
+	if (!offset)
+	{
+	    offset = ucs4 % font->rehash_value;
+	    if (!offset)
+		offset = 1;
+	}
+	ent = ent + offset;
+	if (ent >= font->hash_value)
+	    ent -= font->hash_value;
+    }
+    return font->hash_table[ent].glyph;
+}
+
+/*
+ * Pick a random glyph from the font and remove it from the cache
+ */
+_X_HIDDEN void
+_XftFontUncacheGlyph (Display *dpy, XftFont *pub)
+{
+    XftFontInt	    *font = (XftFontInt *) pub;
+    unsigned long   glyph_memory;
+    FT_UInt	    glyphindex;
+    XftGlyph	    *xftg;
+    
+    if (!font->glyph_memory)
+	return;
+    if (font->use_free_glyphs)
+    {
+	glyph_memory = rand() % font->glyph_memory;
+    }
+    else
+    {
+	if (font->glyphset)
+	{
+	    XRenderFreeGlyphSet (dpy, font->glyphset);
+	    font->glyphset = 0;
+	}
+	glyph_memory = 0;
+    }
+	
+    if (XftDebug() & XFT_DBG_CACHE)
+	_XftFontValidateMemory (dpy, pub);
+    for (glyphindex = 0; glyphindex < font->num_glyphs; glyphindex++)
+    {
+	xftg = font->glyphs[glyphindex];
+	if (xftg)
+	{
+	    if (xftg->glyph_memory > glyph_memory)
+	    {
+		if (XftDebug() & XFT_DBG_CACHEV)
+		    printf ("Uncaching glyph 0x%x size %ld\n",
+			    glyphindex, xftg->glyph_memory);
+		XftFontUnloadGlyphs (dpy, pub, &glyphindex, 1);
+		if (!font->use_free_glyphs)
+		    continue;
+		break;
+	    }
+	    glyph_memory -= xftg->glyph_memory;
+	}
+    }
+    if (XftDebug() & XFT_DBG_CACHE)
+	_XftFontValidateMemory (dpy, pub);
+}
+
+_X_HIDDEN void
+_XftFontManageMemory (Display *dpy, XftFont *pub)
+{
+    XftFontInt	*font = (XftFontInt *) pub;
+
+    if (font->max_glyph_memory)
+    {
+	if (XftDebug() & XFT_DBG_CACHE)
+	{
+	    if (font->glyph_memory > font->max_glyph_memory)
+		printf ("Reduce memory for font 0x%lx from %ld to %ld\n",
+			font->glyphset ? font->glyphset : (unsigned long) font,
+			font->glyph_memory, font->max_glyph_memory);
+	}
+	while (font->glyph_memory > font->max_glyph_memory)
+	    _XftFontUncacheGlyph (dpy, pub);
+    }
+    _XftDisplayManageMemory (dpy);
+}
diff -Naur libXft-2.1.14.orig/src/xftglyphs.c.rej libXft-2.1.14/src/xftglyphs.c.rej
--- libXft-2.1.14.orig/src/xftglyphs.c.rej	1970-01-01 01:00:00.000000000 +0100
+++ libXft-2.1.14/src/xftglyphs.c.rej	2009-10-17 14:27:29.000000000 +0200
@@ -0,0 +1,188 @@
+***************
+*** 21,43 ****
+   */
+  
+  #include "xftint.h"
+- #include <freetype/ftoutln.h>
+  
+- static const int    filters[3][3] = {
+-     /* red */
+- #if 0
+- {    65538*4/7,65538*2/7,65538*1/7 },
+-     /* green */
+- {    65536*1/4, 65536*2/4, 65537*1/4 },
+-     /* blue */
+- {    65538*1/7,65538*2/7,65538*4/7 },
+  #endif
+- {    65538*9/13,65538*3/13,65538*1/13 },
+-     /* green */
+- {    65538*1/6, 65538*4/6, 65538*1/6 },
+-     /* blue */
+- {    65538*1/13,65538*3/13,65538*9/13 },
+- };
+  
+  /*
+   * Validate the memory info for a font
+--- 21,34 ----
+   */
+  
+  #include "xftint.h"
+  
++ #if FREETYPE_MAJOR*10000 + FREETYPE_MINOR*100 + FREETYPE_PATCH < 20202
++ #  error  "FreeType 2.2.2 or later required to compile this version of libXft"
+  #endif
++ 
++ #include FT_OUTLINE_H
++ #include FT_LCD_FILTER_H
++ #include FT_SYNTHESIS_H
+  
+  /*
+   * Validate the memory info for a font
+***************
+*** 455,575 ****
+  	 */
+  	glyph = (Glyph) glyphindex;
+  
+- 	if (subpixel)
+- 	{
+- 	    int		    x, y;
+- 	    unsigned char   *in_line, *out_line, *in;
+- 	    unsigned int    *out;
+- 	    unsigned int    red, green, blue;
+- 	    int		    rf, gf, bf;
+- 	    int		    s;
+- 	    int		    o, os;
+- 	    
+- 	    /*
+- 	     * Filter the glyph to soften the color fringes
+- 	     */
+- 	    widthrgba = width;
+- 	    pitchrgba = (widthrgba * 4 + 3) & ~3;
+- 	    sizergba = pitchrgba * height;
+- 
+- 	    os = 1;
+- 	    switch (font->info.rgba) {
+- 	    case FC_RGBA_VRGB:
+- 		os = pitch;
+- 	    case FC_RGBA_RGB:
+- 	    default:
+- 		rf = 0;
+- 		gf = 1;
+- 		bf = 2;
+- 		break;
+- 	    case FC_RGBA_VBGR:
+- 		os = pitch;
+- 	    case FC_RGBA_BGR:
+- 		bf = 0;
+- 		gf = 1;
+- 		rf = 2;
+- 		break;
+- 	    }
+- 	    if (sizergba > bufSizeRgba)
+- 	    {
+- 		if (bufBitmapRgba != bufLocalRgba)
+- 		    free (bufBitmapRgba);
+- 		bufBitmapRgba = (unsigned char *) malloc (sizergba);
+- 		if (!bufBitmapRgba)
+- 		    continue;
+- 		bufSizeRgba = sizergba;
+- 	    }
+- 	    memset (bufBitmapRgba, 0, sizergba);
+- 	    in_line = bufBitmap;
+- 	    out_line = bufBitmapRgba;
+- 	    for (y = 0; y < height; y++)
+- 	    {
+- 		in = in_line;
+- 		out = (unsigned int *) out_line;
+- 		in_line += pitch * vmul;
+- 		out_line += pitchrgba;
+- 		for (x = 0; x < width * hmul; x += hmul)
+- 		{
+- 		    red = green = blue = 0;
+- 		    o = 0;
+- 		    for (s = 0; s < 3; s++)
+- 		    {
+- 			red += filters[rf][s]*in[x+o];
+- 			green += filters[gf][s]*in[x+o];
+- 			blue += filters[bf][s]*in[x+o];
+- 			o += os;
+- 		    }
+- 		    red = red / 65536;
+- 		    green = green / 65536;
+- 		    blue = blue / 65536;
+- 		    *out++ = (green << 24) | (red << 16) | (green << 8) | blue;
+- 		}
+- 	    }
+- 	    
+- 	    xftg->glyph_memory = sizergba + sizeof (XftGlyph);
+  	    if (font->format)
+  	    {
+  		if (!font->glyphset)
+  		    font->glyphset = XRenderCreateGlyphSet (dpy, font->format);
+- 		if (ImageByteOrder (dpy) != XftNativeByteOrder ())
+- 		    XftSwapCARD32 ((CARD32 *) bufBitmapRgba, sizergba >> 2);
+- 		XRenderAddGlyphs (dpy, font->glyphset, &glyph,
+- 				  &xftg->metrics, 1, 
+- 				  (char *) bufBitmapRgba, sizergba);
+- 	    }
+- 	    else
+- 	    {
+- 		if (sizergba)
+- 		{
+- 		    xftg->bitmap = malloc (sizergba);
+- 		    if (xftg->bitmap)
+- 			memcpy (xftg->bitmap, bufBitmapRgba, sizergba);
+- 		}
+- 		else
+- 		    xftg->bitmap = 0;
+- 	    }
+- 	}
+- 	else
+- 	{
+- 	    xftg->glyph_memory = size + sizeof (XftGlyph);
+- 	    if (font->format)
+- 	    {
+- 		/*
+- 		 * swap bit order around; FreeType is always MSBFirst
+- 		 */
+- 		if (!font->info.antialias)
+  		{
+  		    if (BitmapBitOrder (dpy) != MSBFirst)
+  		    {
+- 			unsigned char   *line;
+- 			unsigned char   c;
+- 			int		    i;
+  
+- 			line = (unsigned char *) bufBitmap;
+- 			i = size;
+  			while (i--)
+  			{
+- 			    c = *line;
+  			    c = ((c << 1) & 0xaa) | ((c >> 1) & 0x55);
+  			    c = ((c << 2) & 0xcc) | ((c >> 2) & 0x33);
+  			    c = ((c << 4) & 0xf0) | ((c >> 4) & 0x0f);
+--- 677,700 ----
+  	 */
+  	glyph = (Glyph) glyphindex;
+  
++         xftg->glyph_memory = size + sizeof (XftGlyph);
+  	    if (font->format)
+  	    {
+  		if (!font->glyphset)
+  		    font->glyphset = XRenderCreateGlyphSet (dpy, font->format);
++ 
++             if ( mode == FT_RENDER_MODE_MONO )
+  		{
++                 /* swap bits in each byte */
+  		    if (BitmapBitOrder (dpy) != MSBFirst)
+  		    {
++                     unsigned char   *line = (unsigned char*)bufBitmap;
++                     int             i = size;
+  
+  			while (i--)
+  			{
++                         int  c = *line;
++ 
+  			    c = ((c << 1) & 0xaa) | ((c >> 1) & 0x55);
+  			    c = ((c << 2) & 0xcc) | ((c >> 2) & 0x33);
+  			    c = ((c << 4) & 0xf0) | ((c >> 4) & 0x0f);
diff -Naur libXft-2.1.14.orig/src/xftint.h libXft-2.1.14/src/xftint.h
--- libXft-2.1.14.orig/src/xftint.h	2008-03-18 23:51:55.000000000 +0100
+++ libXft-2.1.14/src/xftint.h	2009-10-17 14:27:29.000000000 +0200
@@ -145,6 +145,7 @@
     FcBool		antialias;	/* doing antialiasing */
     FcBool		embolden;	/* force emboldening */
     int			rgba;		/* subpixel order */
+    int			lcd_filter;	/* lcd filter */
     FT_Matrix		matrix;		/* glyph transformation matrix */
     FcBool		transform;	/* non-identify matrix? */
     FT_Int		load_flags;	/* glyph load flags */
diff -Naur libXft-2.1.14.orig/xft.pc.in libXft-2.1.14/xft.pc.in
--- libXft-2.1.14.orig/xft.pc.in	2006-07-11 20:05:27.000000000 +0200
+++ libXft-2.1.14/xft.pc.in	2009-10-17 14:26:03.000000000 +0200
@@ -6,7 +6,7 @@
 Name: Xft
 Description: X FreeType library
 Version: @VERSION@
-Requires: xproto, xrender, fontconfig, freetype2
+Requires: xproto
 Requires.private: xrender, fontconfig, freetype2
 Cflags: -I${includedir}
 Libs: -L${libdir} -lXft
